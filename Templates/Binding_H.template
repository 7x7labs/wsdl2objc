
@class %«className»Response;
@class %«className»Operation;
%FOREACH operation in operations
@class %«className»_%«operation.className»;
%ENDFOR

@protocol %«className»ResponseDelegate <NSObject>
@optional

/**
 * Will first try method <name>Operation:completedWithResponse: where <name> is the name of the operation.
 * If delegate does not implement method, it must implement operation:completedWithResponse:
 */
- (void)operation:(%«className»Operation *)operation completedWithResponse:(%«className»Response *)response;

@end

#define kServerAnchorCertificates   @"kServerAnchorCertificates"
#define kServerAnchorsOnly          @"kServerAnchorsOnly"
#define kClientIdentity             @"kClientIdentity"
#define kClientCertificates         @"kClientCertificates"
#define kClientUsername             @"kClientUsername"
#define kClientPassword             @"kClientPassword"
#define kNSURLCredentialPersistence @"kNSURLCredentialPersistence"
#define kValidateResult             @"kValidateResult"

@interface %«className» : NSObject <%«className»ResponseDelegate> {
	BOOL	synchronousOperationComplete;
}

@property (nonatomic, copy) NSURL *address;
@property (nonatomic) BOOL logXMLInOut;
@property (nonatomic) BOOL ignoreEmptyResponse;
@property (nonatomic) NSTimeInterval timeout;
@property (nonatomic, strong) NSMutableArray *cookies;
@property (nonatomic, strong) NSMutableDictionary *customHeaders;
@property (nonatomic, strong) id <SSLCredentialsManaging> sslManager;
@property (nonatomic, strong) SOAPSigner *soapSigner;

+ (NSTimeInterval) defaultTimeout;

- (id)initWithAddress:(NSString *)anAddress;
- (void)sendHTTPCallUsingBody:(NSString *)body soapAction:(NSString *)soapAction forOperation:(%«className»Operation *)operation;
- (void)addCookie:(NSHTTPCookie *)toAdd;
- (NSString *)MIMEType;

%FOREACH operation in operations
- (%«className»Response *)%«operation.invokeString»;
- (%«className»_%«operation.className»*)%«operation.asyncInvokeString» delegate:(id<%«className»ResponseDelegate>)responseDelegate;
%ENDFOR

@end

@interface %«className»Operation : NSOperation <NSURLConnectionDelegate>
@property(nonatomic, strong) %«className» *binding;
@property(nonatomic, strong, readonly) %«className»Response *response;
@property(nonatomic, weak) id <%«className»ResponseDelegate> delegate;
@property(nonatomic, strong) NSMutableData *responseData;
@property(nonatomic, strong) NSURLConnection *urlConnection;

- (id)initWithBinding:(%«className» *)aBinding delegate:(id <%«className»ResponseDelegate>)aDelegate;

/**
 * Cancels connection. Response has error with code kCFURLErrorCancelled in domain kCFErrorDomainCFNetwork.
 */
- (void)cancel;

@end

%FOREACH operation in operations
@interface %«className»_%«operation.className» : %«className»Operation
%FOREACH part in operation.input.body.parts
%IFEQ part.element.type.assignOrRetain strong
@property(nonatomic, strong) %«part.element.type.classNameWithPtr» %«part.name»;
%ELSE
@property(nonatomic) %«part.element.type.classNameWithPtr» %«part.name»;
%ENDIF
%ENDFOR
%FOREACH header in operation.input.headers
%IFEQ header.type.assignOrRetain strong
@property(nonatomic, strong) %«header.type.classNameWithPtr» %«header.name»Header;
%ELSE
@property(nonatomic) %«header.type.classNameWithPtr» %«header.name»Header;
%ENDIF
%ENDFOR

- (id)initWithBinding:(%«className» *)aBinding delegate:(id <%«className»ResponseDelegate>)aDelegate
%FOREACH part in operation.input.body.parts
	%«part.name»:(%«part.element.type.classNameWithPtr»)a%«part.uname»
%ENDFOR
%FOREACH header in operation.input.headers
	%«header.name»:(%«header.type.classNameWithPtr»)a%«header.uname»
%ENDFOR
;

@end
%ENDFOR

@interface %«className»_envelope : NSObject

+ (%«className»_envelope *)sharedInstance;

- (NSString *)serializedFormUsingHeaderElements:(NSDictionary *)headerElements bodyElements:(NSDictionary *)bodyElements bodyKeys:(NSArray *)bodyKeys;

@end

@interface %«className»Response : NSObject

@property(nonatomic, strong) NSArray *headers;
@property(nonatomic, strong) NSArray *bodyParts;
@property(nonatomic, strong) NSError *error;

@end
