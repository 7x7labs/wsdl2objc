@implementation %«className»

@synthesize address;
@synthesize logXMLInOut;

- (id)init
{
	if((self = [super init])) {
		address = nil;
		cookies = nil;
		logXMLInOut = NO;
	}
	
	return self;
}

- (id)initWithAddress:(NSString *)anAddress
{
	if((self = [self init])) {
		self.address = [NSURL URLWithString:anAddress];
	}
	
	return self;
}

- (void)addCookie:(NSHTTPCookie *)toAdd
{
	if(toAdd != nil) {
		if(cookies == nil) cookies = [[NSMutableArray alloc] init];
		[cookies addObject:toAdd];
	}
}

%FOREACH operation in operations
- (%«className»Response *)%«operation.invokeString»
{
	%«className»_%«operation.name» *operation = [(%«className»_%«operation.name»*)[%«className»_%«operation.name» alloc] initWithBinding:self
%FOREACH part in operation.input.body.parts
		%«part.name»:a%«part.uname»
%ENDFOR
%FOREACH header in operation.input.headers
		%«header.name»:a%«header.uname»
%ENDFOR
	];
	
	NSOperationQueue *queue = [[NSOperationQueue new] autorelease];
	
	[queue addOperation:operation];
	
	[queue waitUntilAllOperationsAreFinished];
	
	return operation.response;
}
%ENDFOR

- (NSString *)sendHTTPCallUsingBody:(NSString *)outputBody soapAction:(NSString *)soapAction
{
	NSMutableDictionary *HTTPHeaders = [NSMutableDictionary dictionary];
	if(cookies != nil) {
		NSDictionary *fCookies = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
		[HTTPHeaders addEntriesFromDictionary:fCookies];
	}
	[HTTPHeaders setObject:@"wsdl2objc" forKey:@"UserAgent"];
	[HTTPHeaders setObject:soapAction forKey:@"SOAPAction"];
	[HTTPHeaders setObject:@"text/xml" forKey:@"Content-type"];
    
	CFHTTPMessageRef request = CFHTTPMessageCreateRequest(kCFAllocatorDefault, (CFStringRef)@"POST", (CFURLRef)self.address, kCFHTTPVersion1_1);
	
	CFDataRef bodyData = (CFDataRef)[outputBody dataUsingEncoding:NSUTF8StringEncoding];
	CFHTTPMessageSetBody(request, bodyData);
	
	for(NSString *key in [HTTPHeaders allKeys]) {
		CFHTTPMessageSetHeaderFieldValue(request, (CFStringRef)key, (CFStringRef)[HTTPHeaders objectForKey:key]);
	}
	
	NSDictionary *outputHeaders = (NSDictionary*)CFHTTPMessageCopyAllHeaderFields(request);
	
	if(self.logXMLInOut) {
		NSLog(@"OutputHeaders:\n%@", outputHeaders);
		NSLog(@"OutputBody:\n%@", outputBody);
	}
	
	CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, request);
	
	if(!CFReadStreamOpen(readStream)) {
		CFStreamError myErr = CFReadStreamGetError(readStream);
		// An error has occurred.
        if (myErr.domain == kCFStreamErrorDomainPOSIX) {
        // Interpret myErr.error as a UNIX errno.
        } else if (myErr.domain == kCFStreamErrorDomainMacOSStatus) {
        // Interpret myErr.error as a MacOS error code.
            //OSStatus macError = (OSStatus)myErr.error;
        // Check other error domains.
		}
        return nil;
	}
	
	CFReadStreamSetProperty(readStream, kCFStreamPropertyHTTPShouldAutoredirect, kCFBooleanTrue);
	
	//CFHTTPMessageRef response = (CFHTTPMessageRef)CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
	//NSString *statusLine = (NSString*)CFHTTPMessageCopyResponseStatusLine(response);
	
	NSMutableString *responseBody = [NSMutableString string];
	
	static unsigned int kReadBufSize = 1024;
	CFIndex numBytesRead;
	do {
		UInt8 buf[kReadBufSize];
		numBytesRead = CFReadStreamRead(readStream, buf, sizeof(buf));
		if( numBytesRead > 0 ) {
			[responseBody appendString:[[[NSString alloc] initWithBytes:buf length:numBytesRead encoding:NSUTF8StringEncoding] autorelease]];
		} else if( numBytesRead < 0 ) {
			//CFStreamError error = CFReadStreamGetError(readStream);
			//[[NSApplication sharedApplication] presentError:(NSError*)error];
            return nil;
		}
	} while( numBytesRead > 0 );
	
	CFHTTPMessageRef response = (CFHTTPMessageRef)CFReadStreamCopyProperty(readStream, kCFStreamPropertyHTTPResponseHeader);
	
    NSDictionary *responseHeaders = nil;
    if(cookies) [cookies release];
	
    if (response) {
        responseHeaders = (NSDictionary*)CFHTTPMessageCopyAllHeaderFields(response);
        [responseHeaders autorelease];
        
        cookies = [[NSHTTPCookie cookiesWithResponseHeaderFields:responseHeaders forURL:self.address] mutableCopy];
    }
	
	if(self.logXMLInOut) {
		NSLog(@"ResponseHeaders:\n%@", responseHeaders);
		NSLog(@"ResponseBody:\n%@", responseBody);
	}
    
    CFRelease(request);
    [outputHeaders release];
	CFRelease(readStream);
    CFRelease(response);
    
	return responseBody;
}

@end

%FOREACH operation in operations
@implementation %«className»_%«operation.name»

@synthesize binding;
@synthesize response;
%FOREACH part in operation.input.body.parts
@synthesize %«part.name»;
%ENDFOR
%FOREACH header in operation.input.headers
@synthesize %«header.name»;
%ENDFOR

- (id)initWithBinding:(%«className» *)aBinding
%FOREACH part in operation.input.body.parts
  %«part.name»:(%«part.element.type.classNameWithPtr»)a%«part.uname»
%ENDFOR
%FOREACH header in operation.input.headers
  %«header.name»:(%«header.type.classNameWithPtr»)a%«header.uname»
%ENDFOR
{
	if((self = [super init])) {
		response = nil;
		
		self.binding = aBinding;
		
%FOREACH part in operation.input.body.parts
		self.%«part.name» = a%«part.uname»;
%ENDFOR
%FOREACH header in operation.input.headers
		self.%«header.name» = a%«header.uname»;
%ENDFOR
	}
	
	return self;
}

- (void)dealloc
{
	if(binding != nil) [binding release];
%FOREACH part in operation.input.body.parts
%IFEQ part.element.type.assignOrRetain retain
	if(%«part.name» != nil) [%«part.name» release];
%ENDIF
%ENDFOR
%FOREACH header in operation.input.headers
%IFEQ header.type.assignOrRetain retain
	if(%«header.name» != nil) [%«header.name» release];
%ENDIF
%ENDFOR
	[response release], response = nil;
	[super dealloc];
}

- (void)main
{
	%«className»_envelope *envelope = [%«className»_envelope sharedInstance];
	
	NSMutableDictionary *headerElements = nil;
%IFDEF operation.input.headers
	headerElements = [NSMutableDictionary dictionary];
%FOREACH header in operation.input.headers
%IFEQ header.type.assignOrRetain retain
		if(%«header.name» != nil) [headerElements setObject:%«header.name» forKey:@"%«header.name»"];
%ELSIFEQ header.type.typeName boolean
		if(%«header.name» != nil) [headerElements setObject:[[[USBoolean alloc] initWithBool:*%«header.name»] autorelease] forKey:@"%«header.name»"];
%ELSIFEQ header.type.typeName long
		if(%«header.name» != nil) [headerElements setObject:[NSNumber numberWithLong:*%«header.name»] forKey:@"%«header.name»"];
%ELSIFEQ header.type.typeName short
		if(%«header.name» != nil) [headerElements setObject:[NSNumber numberWithShort:*%«header.name»] forKey:@"%«header.name»"];
%ELSIFEQ header.type.typeName int
		if(%«header.name» != nil) [headerElements setObject:[NSNumber numberWithInt:*%«header.name»] forKey:@"%«header.name»"];
%ELSIFEQ header.type.typeName double
		if(%«header.name» != nil) [headerElements setObject:[NSNumber numberWithDouble:*%«header.name»] forKey:@"%«header.name»"];
%ELSIFEQ header.type.typeName float
		if(%«header.name» != nil) [headerElements setObject:[NSNumber numberWithFloat:*%«header.name»] forKey:@"%«header.name»"];
%ELSIFNEQ header.type.enumCount 0
		if(%«header.name» != nil) [headerElements setObject:%«header.type.className»StringFromEnum(%«header.name») forKey:@"%«header.name»"];
%ENDIF
%ENDFOR
%ENDIF
	
	NSMutableDictionary *bodyElements = nil;
%IFDEF operation.input.body.parts
	bodyElements = [NSMutableDictionary dictionary];
%FOREACH part in operation.input.body.parts
%IFEQ part.element.type.assignOrRetain retain
		if(%«part.name» != nil) [bodyElements setObject:%«part.name» forKey:@"%«part.element.name»"];
%ELSIFEQ part.element.type.typeName boolean
		if(%«part.name» != nil) [bodyElements setObject:[[[USBoolean alloc] initWithBool:*%«part.name»] autorelease] forKey:@"%«part.element.name»"];
%ELSIFEQ part.element.type.typeName long
		if(%«part.name» != nil) [bodyElements setObject:[NSNumber numberWithLong:*%«part.name»] forKey:@"%«part.element.name»"];
%ELSIFEQ part.element.type.typeName short
		if(%«part.name» != nil) [bodyElements setObject:[NSNumber numberWithShort:*%«part.name»] forKey:@"%«part.element.name»"];
%ELSIFEQ part.element.type.typeName int
		if(%«part.name» != nil) [bodyElements setObject:[NSNumber numberWithInt:*%«part.name»] forKey:@"%«part.element.name»"];
%ELSIFEQ part.element.type.typeName double
		if(%«part.name» != nil) [bodyElements setObject:[NSNumber numberWithDouble:*%«part.name»] forKey:@"%«part.element.name»"];
%ELSIFEQ part.element.type.typeName float
		if(%«part.name» != nil) [bodyElements setObject:[NSNumber numberWithFloat:*%«part.name»] forKey:@"%«part.element.name»"];
%ELSIFNEQ part.element.type.enumCount 0
		if(%«part.name» != nil) [bodyElements setObject:%«part.type.className»StringFromEnum(%«part.name») forKey:@"%«part.element.name»"];
%ENDIF
%ENDFOR
%ENDIF
	
	NSString *operationXMLString = [envelope serializedFormUsingHeaderElements:headerElements bodyElements:bodyElements];
	
	NSString *responseBody = [binding sendHTTPCallUsingBody:operationXMLString soapAction:@"%«operation.soapAction»"];
	
    if (!responseBody) {
        return;
    }
    
    [response autorelease];
	response = [%«className»Response new];
    
	xmlDocPtr doc;
	xmlNodePtr cur;
	
	const char *buffer = [responseBody cStringUsingEncoding:NSUTF8StringEncoding];
	
	doc = xmlParseMemory(buffer, [responseBody length]);
	
	NSAssert(doc != NULL, @"Errors while parsing returned XML");
	
	cur = xmlDocGetRootElement(doc);
	cur = cur->children;
	
	for( ; cur != NULL ; cur = cur->next) {
		if(cur->type == XML_ELEMENT_NODE) {
%IF operation.output.hasHeaders
			if(xmlStrEqual(cur->name, (const xmlChar *) "Header")) {
				NSMutableArray *responseHeaders = [NSMutableArray array];
				
				xmlNodePtr headerNode;
				for(headerNode=cur->children ; headerNode != NULL ; headerNode = headerNode->next) {
					if(cur->type == XML_ELEMENT_NODE) {
%FOREACH header in operation.output.headers
						if(xmlStrEqual(headerNode->name, (const xmlChar *) "%«header.name»")) {
							%«header.type.classNameWithoutPtr» *headerObject = [%«header.type.classNameWithoutPtr» deserializeNode:headerNode];
							NSAssert1(headerObject != nil, @"Errors while parsing header %s", headerNode->name);
							[responseHeaders addObject:headerObject];
						}
%ENDFOR
					}
				}
				
				response.headers = responseHeaders;
			}
%ENDIF
			
			if(xmlStrEqual(cur->name, (const xmlChar *) "Body")) {
				NSMutableArray *responseBodyParts = [NSMutableArray array];
				
				xmlNodePtr bodyNode;
				for(bodyNode=cur->children ; bodyNode != NULL ; bodyNode = bodyNode->next) {
					if(cur->type == XML_ELEMENT_NODE) {
%FOREACH part in operation.output.body.parts
						if(xmlStrEqual(bodyNode->name, (const xmlChar *) "%«part.element.name»")) {
							%«part.element.type.classNameWithoutPtr» *bodyObject = [%«part.element.type.classNameWithoutPtr» deserializeNode:bodyNode];
							NSAssert1(bodyObject != nil, @"Errors while parsing body %s", bodyNode->name);
							[responseBodyParts addObject:bodyObject];
						}
%ENDFOR
					}
				}
				
				response.bodyParts = responseBodyParts;
			}
		}
	}
	
	xmlFreeDoc(doc);
	
	xmlCleanupParser();
}

@end
%ENDFOR

static %«className»_envelope *%«className»SharedEnvelopeInstance = nil;
@implementation %«className»_envelope

+ (%«className»_envelope *)sharedInstance
{
	if(%«className»SharedEnvelopeInstance == nil) {
		%«className»SharedEnvelopeInstance = [%«className»_envelope new];
	}
	
	return %«className»SharedEnvelopeInstance;
}

- (NSString *)serializedFormUsingHeaderElements:(NSDictionary *)headerElements bodyElements:(NSDictionary *)bodyElements
{
	NSMutableString *serializedForm = [NSMutableString string];
	
	[serializedForm appendFormat:@"<?xml version=\"1.0\" encoding=\"utf-8\"?>\n"];
	[serializedForm appendFormat:@"<soap:Envelope xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\"\n"];
	[serializedForm appendFormat:@"xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xsl:version=\"1.0\"\n"];
	[serializedForm appendFormat:@"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"];
%FOREACH schema in schema.wsdl.schemas
	[serializedForm appendFormat:@"xmlns:%«schema.prefix»=\"%«schema.fullName»\"\n"];
%ENDFOR
	[serializedForm appendFormat:@">\n"];
	
	if(headerElements != nil) {
		[serializedForm appendFormat:@"<soap:Header>\n"];
		
		for(NSString *key in [headerElements allKeys]) {
			id header = [headerElements objectForKey:key];
			NSString *elementName = [NSString stringWithFormat:@"%@:%@", [header nsPrefix], key];
			
			[serializedForm appendFormat:@"%@\n", [header serializedFormUsingElementName:elementName]];
		}
		
		[serializedForm appendFormat:@"</soap:Header>"];
	}
	
	if(bodyElements != nil) {
		[serializedForm appendFormat:@"<soap:Body>\n"];
		
		for(NSString *key in [bodyElements allKeys]) {
			id body = [bodyElements objectForKey:key];
			NSString *elementName = [NSString stringWithFormat:@"%@:%@", [body nsPrefix], key];
			
			[serializedForm appendFormat:@"%@\n", [body serializedFormUsingElementName:elementName]];
		}
		
		[serializedForm appendFormat:@"</soap:Body>\n"];
	}
	
	[serializedForm appendFormat:@"</soap:Envelope>"];
	
	return serializedForm;
}

@end

@implementation %«className»Response

@synthesize headers;
@synthesize bodyParts;

- (id)init
{
	if((self = [super init])) {
		headers = nil;
		bodyParts = nil;
	}
	
	return self;
}

- (void)dealloc {
    [headers release], headers = nil;
    [bodyParts release], bodyParts = nil;
    [super dealloc];
}

@end
