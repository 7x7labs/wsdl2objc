@implementation %«className»

%IFEQ superClass.className "NSString *"
%IFDEF attributes
%DEFINE IsAttributedString 1
%ENDIF
%ENDIF

%IFDEF sequenceElements
- (id)init
{
	if((self = [super init])){
%FOREACH element in sequenceElements
%IF element.useAnArray
		_%«element.name» = [[NSMutableArray alloc] init];
%ENDIF
%ENDFOR
	}

	return self;
}
%ENDIF

- (NSString *)nsPrefix
{
	return @"%«schema.prefix»";
}

- (xmlNodePtr)xmlNodeForDoc:(xmlDocPtr)doc elementName:(NSString *)elName elementNSPrefix:(NSString *)elNSPrefix
{
	NSString *nodeName = elName;
	if ([elNSPrefix length])
		nodeName = [NSString stringWithFormat:@"%@:%@", elNSPrefix, elName];

%IFDEF IsAttributedString
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], [self._content xmlString]);
%ELSE
	xmlNodePtr node = xmlNewDocNode(doc, NULL, [nodeName xmlString], NULL);
%ENDIF
%IFDEF superClass

	xmlNodePtr	root = xmlDocGetRootElement(doc);
	xmlNsPtr	xsi = xmlSearchNs(doc, root, (const xmlChar *)"xsi");

	xmlSetNsProp(node, xsi, (const xmlChar *)"type", (const xmlChar *)[[[self nsPrefix] stringByAppendingString:@":%«typeName»"] UTF8String]);
%ENDIF

	[self addAttributesToNode:node];
%IF hasSequenceElements
	[self addElementsToNode:node];
%ENDIF

	return node;
}

- (void)addAttributesToNode:(xmlNodePtr)node
{
%IFDEF superClass
%IF superClassIsComplex
	[super addAttributesToNode:node];

%ENDIF
%ENDIF
%IFDEF attributes
%FOREACH attribute in attributes
	if (self.%«attribute.name») {
%IFEQ attribute.type.assignOrRetain strong
		xmlSetProp(node, (const xmlChar *)"%«attribute.wsdlName»", [[self.%«attribute.name» description] xmlString]);
%ELSIFEQ attribute.type.typeName boolean
		xmlSetProp(node, (const xmlChar *)"%«attribute.wsdlName»", (*self.%«attribute.name» ? (const xmlChar *)"true" : (const xmlChar *)"false"));
%ELSIFEQ attribute.type.typeName long
		char buf[20];
		sprintf(buf, "%d", *self.%«attribute.name»);
		xmlSetProp(node, (const xmlChar *)"%«attribute.wsdlName»", buf);
%ELSIFEQ attribute.type.typeName short
		char buf[20];
		sprintf(buf, "%d", *self.%«attribute.name»);
		xmlSetProp(node, (const xmlChar *)"%«attribute.wsdlName»", buf);
%ELSIFEQ attribute.type.typeName int
		char buf[20];
		sprintf(buf, "%d", *self.%«attribute.name»);
		xmlSetProp(node, (const xmlChar *)"%«attribute.wsdlName»", buf);
%ELSIFEQ attribute.type.typeName double
		char buf[20];
		sprintf(buf, "%f", *self.%«attribute.name»);
		xmlSetProp(node, (const xmlChar *)"%«attribute.wsdlName»", buf);
%ELSIFNEQ attribute.type.enumCount 0
		xmlSetProp(node, (const xmlChar *)"%«attribute.wsdlName»", [%«attribute.type.className»_stringFromEnum(self.%«attribute.name») xmlString]);
%ENDIF
	}

%ENDFOR
%ENDIF
}

- (void)addElementsToNode:(xmlNodePtr)node
{
%IFDEF superClass
%IF superClassIsComplex
	[super addElementsToNode:node];

%ENDIF
%ENDIF
%IFDEF sequenceElements
%FOREACH element in sequenceElements
	if (self.%«element.name») {
%IFEQ element.type.assignOrRetain strong
%IF element.useAnArray
		for (%«element.type.classNameWithPtr» child in self.%«element.name») {
			xmlAddChild(node, [child xmlNodeForDoc:node->doc elementName:@"%«element.wsdlName»" elementNSPrefix:[self nsPrefix]]);
		}
%ELSE
		xmlAddChild(node, [self.%«element.name» xmlNodeForDoc:node->doc elementName:@"%«element.wsdlName»" elementNSPrefix:[self nsPrefix]]);
%ENDIF
%ELSIFEQ element.type.typeName boolean
		xmlNewChild(node, NULL, (const xmlChar *)"%«element.wsdlName»", (*self.%«element.name» ? (const xmlChar *)"true" : (const xmlChar *)"false"));
%ELSIFEQ element.type.typeName long
		char buf[20];
		sprintf(buf, "%d", *self.%«element.name»);
		xmlNewChild(node, NULL, (const xmlChar *)"%«element.wsdlName»", buf);
%ELSIFEQ element.type.typeName short
		char buf[20];
		sprintf(buf, "%d", *self.%«element.name»);
		xmlNewChild(node, NULL, (const xmlChar *)"%«element.wsdlName»", buf);
%ELSIFEQ element.type.typeName int
		char buf[20];
		sprintf(buf, "%d", *self.%«element.name»);
		xmlNewChild(node, NULL, (const xmlChar *)"%«element.wsdlName»", buf);
%ELSIFEQ element.type.typeName double
		char buf[20];
		sprintf(buf, "%f", *self.%«element.name»);
		xmlNewChild(node, NULL, (const xmlChar *)"%«element.wsdlName»", buf);
%ELSIFNEQ element.type.enumCount 0

%IF element.useAnArray
		for(NSNumber *intRepresentation in self.%«element.name»){
			%«element.type.className»	enumRepresentation = (%«element.type.className»)[intRepresentation intValue];

			xmlNewChild(node, NULL, (const xmlChar *)"%«element.wsdlName»", [%«element.type.className»_stringFromEnum(enumRepresentation) xmlString]);
		}
%ELSE
		xmlNewChild(node, NULL, (const xmlChar *)[[[self nsPrefix] stringByAppendingString:@":%«element.wsdlName»"] UTF8String], [%«element.type.className»_stringFromEnum(self.%«element.name») xmlString]);
%ENDIF
%ENDIF
	}
%ENDFOR
%ENDIF
}
%IFDEF sequenceElements

// MARK: elements

%FOREACH element in sequenceElements
%IF element.useAnArray

- (void)add%«element.uname»:(%«element.type.classNameWithPtr»)toAdd
{
%IFEQ element.type.assignOrRetain weak
	[self.%«element.name» addObject:[NSNumber numberWithInt:(int)toAdd]];
%ELSE
	if (toAdd)
		[self.%«element.name» addObject:toAdd];
%ENDIF
}
%ENDIF

%ENDFOR
%ENDIF

%IFDEF attributes
// MARK: attributes

- (NSDictionary *)attributes
{
	return @{
%FOREACH attribute in attributes
%IFEQ attribute.type.assignOrRetain strong
		@"%«attribute.wsdlName»": self.%«attribute.name»,
%ELSE
		@"%«attribute.wsdlName»": @(self.%«attribute.name»),
%ENDIF
%ENDFOR
	};
}

%ENDIF
+ (%«classNameWithPtr»)deserializeNode:(xmlNodePtr)cur
{
	%«className» *newObject = [self new];
	
%IFDEF IsAttributedString
	// Set the string content
	xmlChar *theContent = xmlNodeGetContent(cur);
	if (theContent != NULL) {
		newObject._content = [NSString stringWithCString:(char*)theContent encoding:NSUTF8StringEncoding];
		xmlFree(theContent);
	}
%ENDIF

	[newObject deserializeAttributesFromNode:cur];
	[newObject deserializeElementsFromNode:cur];
	
	return newObject;
}

- (void)deserializeAttributesFromNode:(xmlNodePtr)cur
{
%IFDEF superClass
%IF superClassIsComplex
	[super deserializeAttributesFromNode:cur];

%ENDIF
%ENDIF
%IF hasAttributes
	xmlChar	*attrValue = NULL;

%FOREACH attribute in attributes
	attrValue = xmlGetProp(cur, (const xmlChar *)"%«attribute.wsdlName»");
	if (attrValue) {
		NSString	*attrString = [NSString stringWithCString:(char *)attrValue encoding:NSUTF8StringEncoding];
%IFEQ attribute.type.typeName boolean
		self.%«attribute.name» = [[USBoolean alloc] initWithBool:[attrString boolValue]];
%ELSIFEQ attribute.type.typeName byte
		self.%«attribute.name» = @([attrString intValue]);
%ELSIFEQ attribute.type.typeName int
		self.%«attribute.name» = @([attrString intValue]);
%ELSIFEQ attribute.type.typeName integer
		self.%«attribute.name» = @([attrString intValue]);
%ELSIFEQ attribute.type.typeName nonNegativeInteger
		self.%«attribute.name» = @([attrString intValue]);
%ELSIFEQ attribute.type.typeName positiveInteger
		self.%«attribute.name» = @([attrString intValue]);
%ELSIFEQ attribute.type.typeName unsignedByte
		self.%«attribute.name» = @([attrString intValue]);
%ELSIFEQ attribute.type.typeName unsignedInt
		self.%«attribute.name» = @([attrString intValue]);
%ELSIFEQ attribute.type.typeName double
		self.%«attribute.name» = @([attrString doubleValue]);
%ELSIFEQ attribute.type.typeName long
		self.%«attribute.name» = @([attrString longValue]);
%ELSIFEQ attribute.type.typeName unsignedLong
		self.%«attribute.name» = @([attrString intValue]);
%ELSIFEQ attribute.type.typeName short
		self.%«attribute.name» = @([attrString shortValue]);
%ELSIFEQ attribute.type.typeName unsignedShort
		self.%«attribute.name» = @([attrString intValue]);
%ELSIFEQ attribute.type.typeName float
		self.%«attribute.name» = @([attrString doubleValue]);
%ELSIFEQ attribute.type.typeName dateTime
		self.%«attribute.name» = [NSDate dateWithISO8601String:attrString];
%ELSIFEQ attribute.type.typeName date
		self.%«attribute.name» = [NSDate dateWithISO8601String:attrString];
%ELSIFEQ attribute.type.typeName time
		self.%«attribute.name» = [NSDate dateWithISO8601String:attrString];
%ELSIFEQ attribute.type.typeName duration
		self.%«attribute.name» = [NSDate dateWithISO8601String:attrString];
%ELSIFEQ attribute.type.typeName base64Binary
		self.%«attribute.name» = [NSData dataWithBase64EncodedString:base64Binary];
%ELSIFEQ attribute.type.typeName decimal
		self.%«attribute.name» = @([attrString doubleValue]);
%ELSIFEQ attribute.type.typeName QName
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName anyURI
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName string
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName normalizedString
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName token
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName language
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName Name
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName NCName
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName anyType
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName ID
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName ENTITY
		self.%«attribute.name» = attrString;
%ELSIFEQ attribute.type.typeName IDREF
		self.%«attribute.name» = attrString;
%ELSIFNEQ attribute.type.enumCount 0
		self.%«attribute.name» = %«attribute.type.className»_enumFromString(attrString);
%ELSIF attribute.type.isSimpleType
		self.%«attribute.name» = attrString;
%ELSE
#warning Not handling attribute %«attribute.name» with type %«attribute.type.typeName»
%ENDIF
		xmlFree(attrValue);
	}
%ENDFOR
%ENDIF
}

- (void)deserializeElementsFromNode:(xmlNodePtr)cur
{
%IFDEF superClass
%IF superClassIsComplex
	[super deserializeElementsFromNode:cur];

%ENDIF
%ENDIF
%IF hasSequenceElements
	for(cur = cur->children; cur != NULL; cur = cur->next ){
		if(cur->type == XML_ELEMENT_NODE){
			xmlChar		*elementText = xmlNodeListGetString(cur->doc, cur->children, 1);
			NSString	*elementString = nil;

			if(elementText != NULL) {
				elementString = [NSString stringWithCString:(char *)elementText encoding:NSUTF8StringEncoding];
				[elementString self]; // avoid compiler warning for unused var
				xmlFree(elementText);
			}
%FOREACH element in sequenceElements
			if(xmlStrEqual(cur->name, (const xmlChar *) "%«element.wsdlName»")){
%IFEQ element.type.assignOrRetain strong
			Class	elementClass = nil;
			xmlChar	*instanceType = xmlGetNsProp(cur, (const xmlChar *) "type", (const xmlChar *) "http://www.w3.org/2001/XMLSchema-instance");

			if(instanceType == NULL){
				elementClass = [%«element.type.classNameWithoutPtr» class];
			}
			else{
				NSString	*elementTypeString = [NSString stringWithCString:(char *)instanceType encoding:NSUTF8StringEncoding];
				NSArray		*elementTypeArray = [elementTypeString componentsSeparatedByString:@":"];
				NSString	*elementClassString = nil;

				if([elementTypeArray count] > 1){
					NSString	*prefix = elementTypeArray[0];
					NSString	*localName = elementTypeArray[1];
					xmlNsPtr	elementNamespace = xmlSearchNs(cur->doc, cur, [prefix xmlString]);
					NSString	*standardPrefix = [USGlobals sharedInstance].wsdlStandardNamespaces[[NSString stringWithCString:(char *)elementNamespace->href encoding:NSUTF8StringEncoding]];

					elementClassString = [NSString stringWithFormat:@"%@_%@", standardPrefix, localName];
				}
				else{
					elementClassString = [elementTypeString stringByReplacingOccurrencesOfString:@":" withString:@"_"];
				}

				elementClass = NSClassFromString(elementClassString);
				xmlFree(instanceType);
			}

			id newChild = [elementClass deserializeNode:cur];

%IF element.useAnArray
			if (newChild)
				[self.%«element.name» addObject:newChild];
%ELSE
			self.%«element.name» = newChild;
%ENDIF

%ELSIFEQ element.type.typeName boolean

			self.%«element.name» = malloc(sizeof(%«element.type.classNameWithoutPtr»));
			*self.%«element.name» = [elementString boolValue];
%ELSIFEQ element.type.typeName long

			self.%«element.name» = malloc(sizeof(%«element.type.classNameWithoutPtr»));
			*self.%«element.name» = (long)[elementString longLongValue];
%ELSIFEQ element.type.typeName short

			self.%«element.name» = malloc(sizeof(%«element.type.classNameWithoutPtr»));
			*self.%«element.name» = (short)[elementString longLongValue];
%ELSIFEQ element.type.typeName int

			self.%«element.name» = malloc(sizeof(%«element.type.classNameWithoutPtr»));
			*self.%«element.name» = [elementString intValue];
%ELSIFEQ element.type.typeName double

			self.%«element.name» = malloc(sizeof(%«element.type.classNameWithoutPtr»));
			*self.%«element.name» = [elementString doubleValue];
%ELSIFNEQ element.type.enumCount 0
			%«element.type.className» enumRepresentation = %«element.type.className»_enumFromString(elementString);
%IF element.useAnArray
			NSNumber	*intRepresentation = [NSNumber numberWithInt:(int)enumRepresentation];

			[self.%«element.name» addObject:intRepresentation];
%ELSE

			self.%«element.name» = enumRepresentation;
%ENDIF

%ELSE

#warning Not handling element %«element.name» with type %«element.type.typeName»
%ENDIF
			}
%ENDFOR
		}
	}
%ENDIF
}

- (id)initWithCoder:(NSCoder *)decoder
{
%IFDEF superClass
%IFDEF IsAttributedString
	self = [super init];
%ELSE
	self = [super initWithCoder:decoder];
%ENDIF
%ELSE
	self = [super init];
%ENDIF
	decode_object(self, decoder);
	return self;
}

- (void)encodeWithCoder:(NSCoder *)encoder
{
%IFDEF superClass
%IFNDEF IsAttributedString
	[super encodeWithCoder:encoder];

%ENDIF
%ENDIF
	encode_object(self, encoder);
}

@end
